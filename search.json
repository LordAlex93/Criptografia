[
  {
    "objectID": "Tutorial.html",
    "href": "Tutorial.html",
    "title": "Criptosistema de McEliece",
    "section": "",
    "text": "Breve tutorial sobre cómo implementar el criptosistema de McEliece en SageMath.\n\n\nLa versión original del criptosistema McEliece dada por Robert J. McEliece, basado en códigos binarios de Goppa en el año 1978, se describe de la siguiente manera. Los valores de \\(\\textbf{n}\\), \\(\\textbf{k}\\) y \\(\\textbf{t}\\) son parámetros disponibles públicamente, pero \\(L\\), \\(g\\), \\(P\\) y \\(S\\) son secretos generados al azar. Entonces, este criptosistema de clave pública funciona con los siguientes pasos:\nPaso 1: En primer lugar, Alice genera un par de claves públicas y privadas en función de los valores disponibles públicamente. Durante esto:\n\nAlice selecciona un \\(\\left[\\textbf{n},\\textbf{k}\\right]-\\)código binario de Goppa, con su matriz generatriz G de dimensión \\(\\textbf{k}\\times\\textbf{n}\\), capaz de corregir \\(\\textbf{t}\\) errores.\nDespués, selecciona una matriz \\(S\\) binaria, no singular, de dimensión \\(\\textbf{k}\\times\\textbf{k}\\) y una matriz permutación \\(P\\) de dimensión \\(\\textbf{n}\\times\\textbf{n}\\).\nHace el cálculo de la matriz \\(\\textbf{k}\\times\\textbf{n}\\), \\(\\hat{\\textbf{G}}=S\\cdot G\\cdot P\\).\nPublica su clave pública: \\(\\left(\\hat{\\textbf{G}},\\textbf{t}\\right)\\).\nMantiene privada la clave: \\(\\left(S,G,P\\right)\\).\n\nPaso 2: Supongamos que Bob tiene que enviar un mensaje cifrado a Alice:\n\nBob tiene un mensaje binario de texto plano \\(m\\) de longitud \\(k\\).\nCarga la clave pública de Alice: \\(\\left(\\hat{\\textbf{G}},\\textbf{t}\\right)\\).\nGenera un vector aleatorio \\(z\\) de \\(n-\\)bits con peso \\(w(z)=t\\).\nBob calcula el texto cifrado \\(c=m\\cdot\\hat{\\textbf{G}}+z\\) y lo envía a Alice.\n\nPaso 3: Supongamos que Alice ha recibido el texto cifrado \\(c\\). Ella descifra el texto cifrado recibido como:\n\nAlice calcula \\(P^{-1}\\) usando su clave privada.\nMultiplicamos el texto recibido por \\(P^{-1}\\):\\[c\\cdot P^{-1}=m\\cdot S\\cdot G+z\\cdot P^{-1}\\]\nFinalmente, utiliza el algoritmo de descodificación de los códigos Goppa para determinar el valor de \\(m\\).\n\n\n\n\n\n\nPara definir un código de Goppa recurrimos a una de las librerías predefinidas en SageMath.\nDefinamos los parámetros iniciales para obtener un código de Goppa, donde \\(n\\) es la dimensión, \\(\\mathbb{F}_{q^m}\\) el cuerpo donde están definidos los caracteres del mensaje y \\(t\\) se corresponde al grado del polinomio generador del código, al ser un código de Goppa, este parámetro denota la capacidad de corrección del código.\n\n\nCódigo\nn = 14\nq = 2\nm = 4\nt = 2\n\nF.&lt;a&gt;=GF(q**m);\nPolRing=PolynomialRing(F,'x');\nx=PolRing.gen();\n\n\nUna vez que tenemos definidos los parámetros iniciales, el cuerpo en el que vamos a trabajar y la variable del polinomio, tenemos que construir un polinomio \\(g(x)\\) de grado \\(t\\) que sea irreducible. Para ello realizamos el siguiente proceso:\n\n\nCódigo\ng = 0\ncheck = True\nwhile check:\n    h = PolRing.random_element()\n    if h.is_irreducible() and h.degree() == t and h[t]==1:\n        g += h\n        check = False\n    else:\n        None\ng\n\n\nx^2 + (a^3 + a^2 + a)*x + a\n\n\nAl ser \\(g\\) irreducible, para construir el conjunto \\(L\\) nos basta con tomar una muestra aleatoria de tamaño \\(n\\) de elementos del cuerpo \\(\\mathbb{F}_{q^m}\\). Otras definiciones de los códigos de Goppa no exigen que \\(g\\) sea irreducible, con lo que añadimos que para construir \\(L\\) hay que tomar los \\(\\alpha_i \\in \\mathbb{F}_{q^m}\\) tales que \\(g(\\alpha_i)\\neq 0\\) \\(\\forall i\\in\\{1,\\ldots ,n\\}\\). Pasamos pues a construir \\(L\\):\n\n\nCódigo\nL = sample(F.list(),n); L\n\n\n[a^3 + a^2,\n a^3 + a^2 + 1,\n a^3 + a,\n a^2 + a + 1,\n 1,\n a^3,\n a^3 + a^2 + a,\n a^2 + 1,\n a + 1,\n a^2,\n a^3 + 1,\n a,\n 0,\n a^3 + a^2 + a + 1]\n\n\nAl tener \\(g(x)\\) y \\(L\\), que son parámetros necesarios, ya podemos construir un código de Goppa. Para ello, vamos a trabajar con métodos predefinidos de SageMath:\n\n\nCódigo\nC = codes.GoppaCode(g,L); C\n\n\n[14, 6] Goppa code over GF(2)\n\n\nComo podemos ver, ya tenemos un \\([n,k]-\\)código de Goppa \\(\\mathcal{C}\\) definido sobre \\(\\mathbb{F}_{2}\\).\n\n\nCódigo\nG = C.generator_matrix(); G\n\n\n[1 0 0 0 0 1 0 1 0 1 1 1 1 1]\n[0 1 0 0 0 1 0 1 1 1 0 1 0 0]\n[0 0 1 0 0 1 0 0 1 0 0 1 1 0]\n[0 0 0 1 0 1 0 0 1 1 0 0 0 1]\n[0 0 0 0 1 0 0 0 1 1 1 1 0 1]\n[0 0 0 0 0 0 1 1 0 1 1 1 0 0]\n\n\nCon el método C.generator_matrix() obtenemos una matriz generatriz del código.\n\n\nCódigo\nH = C.parity_check_matrix(); H\n\n\n[0 1 0 1 0 0 1 0 1 0 1 0 1 0]\n[1 1 1 1 0 1 0 1 1 1 1 1 0 0]\n[0 1 0 1 1 1 0 1 1 0 1 0 0 1]\n[0 0 1 1 0 0 1 1 0 1 1 0 1 0]\n[1 1 0 1 0 1 1 1 1 0 0 0 0 1]\n[1 0 0 1 0 0 1 1 0 1 1 0 0 0]\n[0 1 0 0 1 1 1 0 0 1 1 1 0 0]\n[1 0 1 1 0 0 0 0 1 1 1 0 0 1]\n\n\nCon el método C.parity_check_matrix() obtenemos una matriz de control del código.\nPara obtener la clave pública, necesitamos calcular \\(k\\) que es la dimensión del código:\n\n\nCódigo\nk = C.dimension(); k\n\n\n6\n\n\n\n\n\nEmpezamos calculando una matriz aleatoria \\(S\\) invertible:\n\n\nCódigo\nS=random_matrix(GF(q),k);\nwhile rank(S) &lt; k:\n    S = random_matrix(GF(q),k);\nS\n\n\n[0 0 1 0 0 1]\n[0 1 0 1 0 1]\n[1 0 1 0 1 1]\n[0 0 0 0 1 1]\n[0 0 1 1 0 1]\n[1 1 1 0 1 1]\n\n\nY ahora calculamos una matriz de permutación \\(P\\):\n\n\nCódigo\ncolumnas = [0..(n-1)]\nP = matrix(GF(q),n)\nfor i in range(n):\n    posicion=randint(0,len(columnas)-1)\n    P[i,columnas.pop(posicion)]=1\nP\n\n\n[0 0 0 0 0 0 0 0 1 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 0 0 0 1]\n[0 1 0 0 0 0 0 0 0 0 0 0 0 0]\n[0 0 0 1 0 0 0 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 1 0 0 0 0 0 0]\n[0 0 0 0 0 1 0 0 0 0 0 0 0 0]\n[0 0 1 0 0 0 0 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 1 0 0 0]\n[0 0 0 0 0 0 1 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 0 0 1 0]\n[0 0 0 0 0 0 0 0 0 1 0 0 0 0]\n[0 0 0 0 1 0 0 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 0 1 0 0]\n[1 0 0 0 0 0 0 0 0 0 0 0 0 0]\n\n\nYa estamos en condiciones de poder calcular una clave pública de nuestro criptosistema:\n\n\nCódigo\nGp = S*G*P; Gp\n\n\n[0 1 1 0 0 1 1 0 0 1 1 1 1 0]\n[1 0 1 1 0 0 0 0 0 1 0 0 1 1]\n[0 1 1 0 0 0 0 1 1 1 0 0 1 0]\n[1 0 1 0 0 0 1 1 0 0 1 0 0 0]\n[1 1 1 1 0 0 0 0 0 1 1 1 0 0]\n[0 1 1 0 1 1 1 1 1 1 1 0 0 1]\n\n\nLa clave pública es la matriz Gp y t.\n\n\nCódigo\n(Gp,t)\n\n\n(\n[0 1 1 0 0 1 1 0 0 1 1 1 1 0]   \n[1 0 1 1 0 0 0 0 0 1 0 0 1 1]   \n[0 1 1 0 0 0 0 1 1 1 0 0 1 0]   \n[1 0 1 0 0 0 1 1 0 0 1 0 0 0]   \n[1 1 1 1 0 0 0 0 0 1 1 1 0 0]   \n[0 1 1 0 1 1 1 1 1 1 1 0 0 1], 2\n)\n\n\nAlice (o nosotros) tenemos el par de claves públicas \\(\\left(\\hat{\\textbf{G}},\\textbf{t}\\right)\\) y mantenemos privadas \\((G,S,P)\\).\n\n\n\n\n\nBob tiene un mensaje binario de texto plano \\(m\\) de longitud \\(k\\). (En este caso lo vamos a generar de forma aleatoria como ejemplo).\n\n\n\nCódigo\nmensaje = vector([GF(q).random_element() for ii in range(C.dimension())]); mensaje\n\n\n(0, 0, 0, 1, 1, 1)\n\n\n\nCarga la clave pública de Alice: \\(\\left(\\hat{\\textbf{G}},\\textbf{t}\\right)\\).\n\n\n\nCódigo\n(Gp,t)\n\n\n(\n[0 1 1 0 0 1 1 0 0 1 1 1 1 0]   \n[1 0 1 1 0 0 0 0 0 1 0 0 1 1]   \n[0 1 1 0 0 0 0 1 1 1 0 0 1 0]   \n[1 0 1 0 0 0 1 1 0 0 1 0 0 0]   \n[1 1 1 1 0 0 0 0 0 1 1 1 0 0]   \n[0 1 1 0 1 1 1 1 1 1 1 0 0 1], 2\n)\n\n\n\nGenera un vector aleatorio \\(z\\) de \\(n-\\)bits con peso \\(w(z)=t\\).\n\nUna de las varias fortalezas de este criptosistema es que codificamos el mensaje añadiendo un error con peso menor o igual que \\(t\\).\n\n\nCódigo\nerror = [GF(q)(0) for ii in range(n)]\nfor ii in range(t): # Con esto aseguramos que el error tenga peso &lt;= t\n    error[ZZ.random_element(n)] = GF(q).random_element()\n\nz = vector(error); z\n\n\n(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0)\n\n\n\nBob calcula el texto cifrado \\(c=m\\cdot\\hat{\\textbf{G}}+z\\) y lo envía a Alice.\n\n\n\nCódigo\nc = mensaje*Gp+z; c\n\n\n(0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1)\n\n\n\n\n\n\nAlice calcula \\(P^{-1}\\) usando su clave privada.\n\n\n\nCódigo\nPinv = P.inverse(); Pinv\n\n\n[0 0 0 0 0 0 0 0 0 0 0 0 0 1]\n[0 0 1 0 0 0 0 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 1 0 0 0 0 0 0 0]\n[0 0 0 1 0 0 0 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 0 1 0 0]\n[0 0 0 0 0 1 0 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 1 0 0 0 0 0]\n[0 0 0 0 1 0 0 0 0 0 0 0 0 0]\n[1 0 0 0 0 0 0 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 1 0 0 0]\n[0 0 0 0 0 0 0 1 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 0 0 1 0]\n[0 0 0 0 0 0 0 0 0 1 0 0 0 0]\n[0 1 0 0 0 0 0 0 0 0 0 0 0 0]\n\n\n\nMultiplicamos el texto recibido por \\(P^{-1}\\):\\[c\\cdot P^{-1}=m\\cdot S\\cdot G+z\\cdot P^{-1}\\]\n\n\n\nCódigo\ncnew = c*Pinv; cnew\n\n\n(1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0)\n\n\n\nFinalmente, utiliza el algoritmo de descodificación de los códigos Goppa para determinar el valor de \\(m\\).\n\nPaso 1: Descodificamos el mensaje cnew. Para ello recurrimos al método predefinido C.decode_to_code().\n\n\nCódigo\nx1 = C.decode_to_code(cnew); x1\n\n\n(1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0)\n\n\nPaso 2: Nos quedamos con las primeras \\(k\\) componentes de \\(x_1\\), las restantes \\(n-k\\) componentes son añadidas simplemente para que el mensaje codificado tenga longitud \\(n\\) no aportando nada de información.\n\n\nCódigo\nx0 = vector([x1[i] for i in range(0,C.dimension())]); x0\n\n\n(1, 1, 0, 1, 0, 1)\n\n\nPaso 3: Recuperamos el mensaje original sin errores.\n\n\nCódigo\nx0*S.inverse()\n\n\n(0, 0, 0, 1, 1, 1)\n\n\nY como se puede observar, hemos desencriptado (y corregido) nuestro mensaje encriptado.",
    "crumbs": [
      "Notebooks",
      "Criptosistema de McEliece"
    ]
  },
  {
    "objectID": "Tutorial.html#paso-1.-generamos-un-par-de-claves-públicas-y-privadas.",
    "href": "Tutorial.html#paso-1.-generamos-un-par-de-claves-públicas-y-privadas.",
    "title": "Criptosistema de McEliece",
    "section": "",
    "text": "Para definir un código de Goppa recurrimos a una de las librerías predefinidas en SageMath.\nDefinamos los parámetros iniciales para obtener un código de Goppa, donde \\(n\\) es la dimensión, \\(\\mathbb{F}_{q^m}\\) el cuerpo donde están definidos los caracteres del mensaje y \\(t\\) se corresponde al grado del polinomio generador del código, al ser un código de Goppa, este parámetro denota la capacidad de corrección del código.\n\n\nCódigo\nn = 14\nq = 2\nm = 4\nt = 2\n\nF.&lt;a&gt;=GF(q**m);\nPolRing=PolynomialRing(F,'x');\nx=PolRing.gen();\n\n\nUna vez que tenemos definidos los parámetros iniciales, el cuerpo en el que vamos a trabajar y la variable del polinomio, tenemos que construir un polinomio \\(g(x)\\) de grado \\(t\\) que sea irreducible. Para ello realizamos el siguiente proceso:\n\n\nCódigo\ng = 0\ncheck = True\nwhile check:\n    h = PolRing.random_element()\n    if h.is_irreducible() and h.degree() == t and h[t]==1:\n        g += h\n        check = False\n    else:\n        None\ng\n\n\nx^2 + (a^3 + a^2 + a)*x + a\n\n\nAl ser \\(g\\) irreducible, para construir el conjunto \\(L\\) nos basta con tomar una muestra aleatoria de tamaño \\(n\\) de elementos del cuerpo \\(\\mathbb{F}_{q^m}\\). Otras definiciones de los códigos de Goppa no exigen que \\(g\\) sea irreducible, con lo que añadimos que para construir \\(L\\) hay que tomar los \\(\\alpha_i \\in \\mathbb{F}_{q^m}\\) tales que \\(g(\\alpha_i)\\neq 0\\) \\(\\forall i\\in\\{1,\\ldots ,n\\}\\). Pasamos pues a construir \\(L\\):\n\n\nCódigo\nL = sample(F.list(),n); L\n\n\n[a^3 + a^2,\n a^3 + a^2 + 1,\n a^3 + a,\n a^2 + a + 1,\n 1,\n a^3,\n a^3 + a^2 + a,\n a^2 + 1,\n a + 1,\n a^2,\n a^3 + 1,\n a,\n 0,\n a^3 + a^2 + a + 1]\n\n\nAl tener \\(g(x)\\) y \\(L\\), que son parámetros necesarios, ya podemos construir un código de Goppa. Para ello, vamos a trabajar con métodos predefinidos de SageMath:\n\n\nCódigo\nC = codes.GoppaCode(g,L); C\n\n\n[14, 6] Goppa code over GF(2)\n\n\nComo podemos ver, ya tenemos un \\([n,k]-\\)código de Goppa \\(\\mathcal{C}\\) definido sobre \\(\\mathbb{F}_{2}\\).\n\n\nCódigo\nG = C.generator_matrix(); G\n\n\n[1 0 0 0 0 1 0 1 0 1 1 1 1 1]\n[0 1 0 0 0 1 0 1 1 1 0 1 0 0]\n[0 0 1 0 0 1 0 0 1 0 0 1 1 0]\n[0 0 0 1 0 1 0 0 1 1 0 0 0 1]\n[0 0 0 0 1 0 0 0 1 1 1 1 0 1]\n[0 0 0 0 0 0 1 1 0 1 1 1 0 0]\n\n\nCon el método C.generator_matrix() obtenemos una matriz generatriz del código.\n\n\nCódigo\nH = C.parity_check_matrix(); H\n\n\n[0 1 0 1 0 0 1 0 1 0 1 0 1 0]\n[1 1 1 1 0 1 0 1 1 1 1 1 0 0]\n[0 1 0 1 1 1 0 1 1 0 1 0 0 1]\n[0 0 1 1 0 0 1 1 0 1 1 0 1 0]\n[1 1 0 1 0 1 1 1 1 0 0 0 0 1]\n[1 0 0 1 0 0 1 1 0 1 1 0 0 0]\n[0 1 0 0 1 1 1 0 0 1 1 1 0 0]\n[1 0 1 1 0 0 0 0 1 1 1 0 0 1]\n\n\nCon el método C.parity_check_matrix() obtenemos una matriz de control del código.\nPara obtener la clave pública, necesitamos calcular \\(k\\) que es la dimensión del código:\n\n\nCódigo\nk = C.dimension(); k\n\n\n6\n\n\n\n\n\nEmpezamos calculando una matriz aleatoria \\(S\\) invertible:\n\n\nCódigo\nS=random_matrix(GF(q),k);\nwhile rank(S) &lt; k:\n    S = random_matrix(GF(q),k);\nS\n\n\n[0 0 1 0 0 1]\n[0 1 0 1 0 1]\n[1 0 1 0 1 1]\n[0 0 0 0 1 1]\n[0 0 1 1 0 1]\n[1 1 1 0 1 1]\n\n\nY ahora calculamos una matriz de permutación \\(P\\):\n\n\nCódigo\ncolumnas = [0..(n-1)]\nP = matrix(GF(q),n)\nfor i in range(n):\n    posicion=randint(0,len(columnas)-1)\n    P[i,columnas.pop(posicion)]=1\nP\n\n\n[0 0 0 0 0 0 0 0 1 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 0 0 0 1]\n[0 1 0 0 0 0 0 0 0 0 0 0 0 0]\n[0 0 0 1 0 0 0 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 1 0 0 0 0 0 0]\n[0 0 0 0 0 1 0 0 0 0 0 0 0 0]\n[0 0 1 0 0 0 0 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 1 0 0 0]\n[0 0 0 0 0 0 1 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 0 0 1 0]\n[0 0 0 0 0 0 0 0 0 1 0 0 0 0]\n[0 0 0 0 1 0 0 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 0 1 0 0]\n[1 0 0 0 0 0 0 0 0 0 0 0 0 0]\n\n\nYa estamos en condiciones de poder calcular una clave pública de nuestro criptosistema:\n\n\nCódigo\nGp = S*G*P; Gp\n\n\n[0 1 1 0 0 1 1 0 0 1 1 1 1 0]\n[1 0 1 1 0 0 0 0 0 1 0 0 1 1]\n[0 1 1 0 0 0 0 1 1 1 0 0 1 0]\n[1 0 1 0 0 0 1 1 0 0 1 0 0 0]\n[1 1 1 1 0 0 0 0 0 1 1 1 0 0]\n[0 1 1 0 1 1 1 1 1 1 1 0 0 1]\n\n\nLa clave pública es la matriz Gp y t.\n\n\nCódigo\n(Gp,t)\n\n\n(\n[0 1 1 0 0 1 1 0 0 1 1 1 1 0]   \n[1 0 1 1 0 0 0 0 0 1 0 0 1 1]   \n[0 1 1 0 0 0 0 1 1 1 0 0 1 0]   \n[1 0 1 0 0 0 1 1 0 0 1 0 0 0]   \n[1 1 1 1 0 0 0 0 0 1 1 1 0 0]   \n[0 1 1 0 1 1 1 1 1 1 1 0 0 1], 2\n)\n\n\nAlice (o nosotros) tenemos el par de claves públicas \\(\\left(\\hat{\\textbf{G}},\\textbf{t}\\right)\\) y mantenemos privadas \\((G,S,P)\\).",
    "crumbs": [
      "Notebooks",
      "Criptosistema de McEliece"
    ]
  },
  {
    "objectID": "Tutorial.html#paso-2-supongamos-que-bob-tiene-que-enviar-un-mensaje-cifrado-a-alice",
    "href": "Tutorial.html#paso-2-supongamos-que-bob-tiene-que-enviar-un-mensaje-cifrado-a-alice",
    "title": "Criptosistema de McEliece",
    "section": "",
    "text": "Bob tiene un mensaje binario de texto plano \\(m\\) de longitud \\(k\\). (En este caso lo vamos a generar de forma aleatoria como ejemplo).\n\n\n\nCódigo\nmensaje = vector([GF(q).random_element() for ii in range(C.dimension())]); mensaje\n\n\n(0, 0, 0, 1, 1, 1)\n\n\n\nCarga la clave pública de Alice: \\(\\left(\\hat{\\textbf{G}},\\textbf{t}\\right)\\).\n\n\n\nCódigo\n(Gp,t)\n\n\n(\n[0 1 1 0 0 1 1 0 0 1 1 1 1 0]   \n[1 0 1 1 0 0 0 0 0 1 0 0 1 1]   \n[0 1 1 0 0 0 0 1 1 1 0 0 1 0]   \n[1 0 1 0 0 0 1 1 0 0 1 0 0 0]   \n[1 1 1 1 0 0 0 0 0 1 1 1 0 0]   \n[0 1 1 0 1 1 1 1 1 1 1 0 0 1], 2\n)\n\n\n\nGenera un vector aleatorio \\(z\\) de \\(n-\\)bits con peso \\(w(z)=t\\).\n\nUna de las varias fortalezas de este criptosistema es que codificamos el mensaje añadiendo un error con peso menor o igual que \\(t\\).\n\n\nCódigo\nerror = [GF(q)(0) for ii in range(n)]\nfor ii in range(t): # Con esto aseguramos que el error tenga peso &lt;= t\n    error[ZZ.random_element(n)] = GF(q).random_element()\n\nz = vector(error); z\n\n\n(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0)\n\n\n\nBob calcula el texto cifrado \\(c=m\\cdot\\hat{\\textbf{G}}+z\\) y lo envía a Alice.\n\n\n\nCódigo\nc = mensaje*Gp+z; c\n\n\n(0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1)",
    "crumbs": [
      "Notebooks",
      "Criptosistema de McEliece"
    ]
  },
  {
    "objectID": "Tutorial.html#paso-3-supongamos-que-alice-ha-recibido-el-texto-cifrado-c.-ella-descifra-el-texto-cifrado-recibido-como",
    "href": "Tutorial.html#paso-3-supongamos-que-alice-ha-recibido-el-texto-cifrado-c.-ella-descifra-el-texto-cifrado-recibido-como",
    "title": "Criptosistema de McEliece",
    "section": "",
    "text": "Alice calcula \\(P^{-1}\\) usando su clave privada.\n\n\n\nCódigo\nPinv = P.inverse(); Pinv\n\n\n[0 0 0 0 0 0 0 0 0 0 0 0 0 1]\n[0 0 1 0 0 0 0 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 1 0 0 0 0 0 0 0]\n[0 0 0 1 0 0 0 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 0 1 0 0]\n[0 0 0 0 0 1 0 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 1 0 0 0 0 0]\n[0 0 0 0 1 0 0 0 0 0 0 0 0 0]\n[1 0 0 0 0 0 0 0 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 1 0 0 0]\n[0 0 0 0 0 0 0 1 0 0 0 0 0 0]\n[0 0 0 0 0 0 0 0 0 0 0 0 1 0]\n[0 0 0 0 0 0 0 0 0 1 0 0 0 0]\n[0 1 0 0 0 0 0 0 0 0 0 0 0 0]\n\n\n\nMultiplicamos el texto recibido por \\(P^{-1}\\):\\[c\\cdot P^{-1}=m\\cdot S\\cdot G+z\\cdot P^{-1}\\]\n\n\n\nCódigo\ncnew = c*Pinv; cnew\n\n\n(1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0)\n\n\n\nFinalmente, utiliza el algoritmo de descodificación de los códigos Goppa para determinar el valor de \\(m\\).\n\nPaso 1: Descodificamos el mensaje cnew. Para ello recurrimos al método predefinido C.decode_to_code().\n\n\nCódigo\nx1 = C.decode_to_code(cnew); x1\n\n\n(1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0)\n\n\nPaso 2: Nos quedamos con las primeras \\(k\\) componentes de \\(x_1\\), las restantes \\(n-k\\) componentes son añadidas simplemente para que el mensaje codificado tenga longitud \\(n\\) no aportando nada de información.\n\n\nCódigo\nx0 = vector([x1[i] for i in range(0,C.dimension())]); x0\n\n\n(1, 1, 0, 1, 0, 1)\n\n\nPaso 3: Recuperamos el mensaje original sin errores.\n\n\nCódigo\nx0*S.inverse()\n\n\n(0, 0, 0, 1, 1, 1)\n\n\nY como se puede observar, hemos desencriptado (y corregido) nuestro mensaje encriptado.",
    "crumbs": [
      "Notebooks",
      "Criptosistema de McEliece"
    ]
  },
  {
    "objectID": "Criptografía/Archivos ipynb/Identificación.html",
    "href": "Criptografía/Archivos ipynb/Identificación.html",
    "title": "Identificación",
    "section": "",
    "text": "q = 1201\np = 122503\nt = 10\nalpha = 11538\n\nZp = IntegerModRing(p)\nZp1 = IntegerModRing(p-1)\nZpu = [a for a in Zp.list() if a.is_unit()]\n\n\n1. Verificar que \\(\\alpha\\) tiene orden \\(q\\) en \\(\\mathbb{Z}_p^*\\).\n\nZp(alpha)^q\n\n1\n\n\n\n\n2. Supongamos que Alice elige como exponente secreto \\(a=357\\). Calcular \\(v\\).\n\na = 357\nv = Zp(alpha^(-a)); v\n\n14320\n\n\n\n\n3. Supongamos que \\(k=868\\). Calcule \\(\\gamma\\).\n\nk = 868\ngamma = Zp(alpha^k); gamma\n\n89937\n\n\n\n\n4. Supongamos que Benito usa el reto \\(r=501\\). Calcule la respuesta de Alicia \\(y\\).\n\nr = 501\nZq = IntegerModRing(q)\ny = Zq(k+a*r); y\n\n776\n\n\n\n\n5. Realice los cálculos de Benito para verificar \\(y\\).\n\nZp(gamma) == Zp(alpha^y)*Zp(v^r)\n\nTrue\n\n\nComo se cumple la congruencia, Benito acepta el mensaje.\n\n\n6. Supongamos que \\(v=51131\\) y Olga ha sabido que \\[\\alpha^3 v^{148}=\\alpha^{151} v^{1077}\\text{ mód }p.\\] Demuestre que Olga puede calcular el número secreto de Alice.\nComenzamos razonando lo que Olga sabe, \\(\\gamma\\equiv \\alpha^3 v^{148} \\equiv \\alpha^{151} v^{1077}\\text{ mód }p\\). Trabajando la ecuación tenemos: \\[\\alpha^{3-151}\\equiv v^{1077-148} \\text{ mód }p.\\] Por otro lado, sabemos que \\(v\\equiv \\alpha ^{-a} \\text{ mód }p\\), con lo que podemos sustituirlo en la ecuación, obteniendo: \\[\\alpha^{3-151}\\equiv \\alpha^{-a(1077-148)}\\text{ mód }p\\] Como \\(\\alpha\\) tiene orden \\(q\\), se cumple la siguiente equivalencia: \\[3-151 \\equiv a(148-1077) \\text{ mód }q.\\] Al ser \\(q\\) primo, tenemos asegurada la existencia del inverso y podemos despejar \\(a\\), obteniendo finalmente: \\[a\\equiv(3-151)(148-1077)^{-1}\\text{ mód }q.\\]\nCon lo que podemos pasar a realizar los cálculos:\n\naa = Zq(3-151)*Zq(148-1077)^(-1); aa\n\n441\n\n\n\nZp(alpha^-aa) == 51131\n\nTrue\n\n\nPor tanto, queda probado que Olga puede conocer el número secreto de Alicia."
  },
  {
    "objectID": "Criptografía/Archivos ipynb/Factorizacion.html",
    "href": "Criptografía/Archivos ipynb/Factorizacion.html",
    "title": "Algoritmo p-1 de Pollard",
    "section": "",
    "text": "def mcm(B):\n    m = lcm(1,2)\n    mm = 0\n    if B == 1:\n        return 1\n    for k in range(3,B+1):\n        mm = lcm(m,k)\n        m = mm\n    return m\n\n\ndef pollardp(n,B,a,A):\n    m = mcm(B)\n    x = (a**m-1) % n\n    g = gcd(x,n)\n    if g != 1:\n        return g\n    while a &lt; A:\n        a+=1\n        x = (a**m-1) % n\n        g = gcd(x,n)\n        if g != 1:\n            return g\n\n\ni) n=1739\n\nB = 10\nn = 1739\npollardp(n,B,2,10)\n\n37\n\n\n\n1739/37\n\n47\n\n\n\nis_prime(47)\n\nTrue\n\n\nTenemos pues que la factorización es: 1739 = 37*47\n\n\nii) n=220459\n\nB = 10\nn = 220459\npollardp(n,B,2,10)\n\n449\n\n\n\nn/pollardp(n,B,2,10)\n\n491\n\n\n\nis_prime(491)\n\nTrue\n\n\nTenemos por tanto que la factorización es: 220459 = 449*491\n\n\niii) n=48356747\n\nB = 20\nn = 48356747\npollardp(n,B,2,10)\n\n6917\n\n\n\nn/pollardp(n,B,2,10)\n\n6991\n\n\n\nis_prime(6991)\n\nTrue\n\n\nTenemos por tanto que la factorización es: 48356747 = 6917*6991\nEl algoritmo ha funcionado ya que en las iteraciones puestas (A) hemos conseguido que mcd(a^A-1,n) != n, obteniendo con esto un factor de n, ya que a^A-1 no es múltiplo de n.\n\n\nEjercicio 2\n\ndef fermat(n):\n    t = int(sqrt(n))+1\n    s = t**2-n\n    while sqrt(s) != int(sqrt(s)):\n        s = t**2-n\n        t +=1\n    return (t-sqrt(s),t+sqrt(s))\n        \n\n\nfermat(53357)\n\n(229, 233)\n\n\n\nfermat(34571)\n\n(181, 191)\n\n\n\nfermat(25777)\n\n(149, 173)\n\n\n\nfermat(64213)\n\n(158, 410)\n\n\n\n\nEjercicio 3\n\ndef fermatext(n,k,binit):\n    b = binit\n    a = sqrt(k*n+b^2)\n    while a != int(a):\n        b += 1\n        a = sqrt(k*n+b^2)\n    m1 = gcd(k*n,a-b)\n    m2 = gcd(k*n,a+b)\n    return m1,m2\n\n\ni) \\(n=203299\\) y \\(k=3\\).\n\nfermatext(203299,3,2)\n\n(773, 789)\n\n\n\nfactor(203299)\n\n263 * 773\n\n\nHemos comprobado que efectivamente hemos encontrado un divisor.\n\n\nii) \\(n=143041\\) y \\(k=247\\).\n\nfermatext(143041,247,2)\n\n(5941, 5947)\n\n\n\nfactor(143041)\n\n313 * 457\n\n\nNo hemos encontrado uno de los factores de nuestro número, el método es estocástico y no implica que siempre se encuentre un factor.\n\n\niii) \\(n=1226987\\) y \\(k=3\\) (comience con \\(b_{init}=36\\)).\n\nfermatext(1226987,3,36)\n\n(1879, 1959)\n\n\n\nfactor(1226987)\n\n653 * 1879\n\n\nPor tanto, hemos encontrado un divisor.\n\n\niv) \\(n=2510839\\) y \\(k=21\\) (comience con \\(b_{init}=90\\)).\n\nfermatext(2510839,21,90)\n\n(7167, 7357)\n\n\n\nfactor(2510839)\n\n1051 * 2389\n\n\nEn este caso tampoco hemos encontrado un factor de nuestro número.\n\n\n\nEjercicio 4\n\ndef f(x):\n    return x**2+1\ndef rhopollard(n,f):\n    a = 2\n    b = 2\n    i = 0\n    while True:\n        a = f(a) % n\n        b = f(f(b)) % n\n        d = gcd(a-b,n)\n        if d != 1 and d &lt; n:\n            return d\n        if d == n:\n            return False\n\n\nnf = []\nfor k in range(5,20):\n    nf.append(2**(2**k)+1)\n\n\ndef fk(x,k):\n    return x**(2**k)+1\ndef rhopollardk(n,k):\n    a = nf[0]\n    b = nf[0]\n    while True:\n        a = fk(a,k) % n\n        b = fk(fk(b,k),k) % n\n        d = gcd(a-b,n)\n        if d != 1 and d &lt; n:\n            return d\n        if d == n:\n            return False\n\ndef ej4():\n    k = 0\n    while k &lt; 8:\n        \n        print(\"k=\"+str(k+5)+\"\\n\")\n        print(rhopollardk(nf[k],k))\n        %time\n        k +=1\n\n\nej4()\n\nk=5\n\n641\nCPU times: user 6 µs, sys: 2 µs, total: 8 µs\nWall time: 14.1 µs\nk=6\n\n274177\nCPU times: user 2 µs, sys: 1e+03 ns, total: 3 µs\nWall time: 3.81 µs\nk=7\n\n59649589127497217\nCPU times: user 1e+03 ns, sys: 0 ns, total: 1e+03 ns\nWall time: 3.1 µs\nk=8\n\n1238926361552897\nCPU times: user 2 µs, sys: 1e+03 ns, total: 3 µs\nWall time: 3.1 µs\nk=9\n\n2424833\nCPU times: user 0 ns, sys: 0 ns, total: 0 ns\nWall time: 1.91 µs\nk=10\n\n45592577\nCPU times: user 1e+03 ns, sys: 1e+03 ns, total: 2 µs\nWall time: 2.15 µs\nk=11\n\n319489\nCPU times: user 2 µs, sys: 1e+03 ns, total: 3 µs\nWall time: 4.77 µs\nk=12\n\n114689\nCPU times: user 1e+03 ns, sys: 0 ns, total: 1e+03 ns\nWall time: 2.15 µs\n\n\n\nnf[0]/641\n\n6700417\n\n\n\nis_prime(6700417)\n\nTrue\n\n\n\nnf[1]/274177\n\n67280421310721\n\n\n\nis_prime(67280421310721)\n\nTrue\n\n\n\nnf[2]/59649589127497217\n\n5704689200685129054721\n\n\n\nis_prime(5704689200685129054721)\n\nTrue\n\n\n\nnf[3]/1238926361552897\n\n93461639715357977769163558199606896584051237541638188580280321\n\n\n\nis_prime(93461639715357977769163558199606896584051237541638188580280321)\n\nTrue\n\n\n\nnf[4]/2424833\n\n5529373746539492451469451709955220061537996975706118061624681552800446063738635599565773930892108210210778168305399196915314944498011438291393118209\n\n\n\nis_prime(5529373746539492451469451709955220061537996975706118061624681552800446063738635599565773930892108210210778168305399196915314944498011438291393118209)\n\nFalse\n\n\n\nnf[5]/45592577\n\n3942951359960012586542991835686376608231592127249807732373409846031135195659174148737161255930050543559319182152642816343958573976075461198274610155058226350701077796608546283231637018483208223116080561800334422176622099740983337736621316898600121619871377542107047343253864459964167331555646795960321\n\n\n\nis_prime(3942951359960012586542991835686376608231592127249807732373409846031135195659174148737161255930050543559319182152642816343958573976075461198274610155058226350701077796608546283231637018483208223116080561800334422176622099740983337736621316898600121619871377542107047343253864459964167331555646795960321)\n\nFalse\n\n\n\nnf[6]/319489\n\n101152171346465785365739905563790778275446424351747584524444802254614885454171789617787158279386499891040749324458425859713854183244152133860909616251101863039512713637405344446131784663602352840930541077733717180487566766438342966931062084574042206368862921265008513729385286790910065162204496552694867070609361616173540692858549041708993328392702647150062512506151403207406283761595736673720405375033810606080158013948717662760215065784116654734290374983906448207065425365852408720566771005345821995341556493590254118091846659097349200248570452085641250044738949182704974520704370036542579394575574913724915713\n\n\n\nis_prime(101152171346465785365739905563790778275446424351747584524444802254614885454171789617787158279386499891040749324458425859713854183244152133860909616251101863039512713637405344446131784663602352840930541077733717180487566766438342966931062084574042206368862921265008513729385286790910065162204496552694867070609361616173540692858549041708993328392702647150062512506151403207406283761595736673720405375033810606080158013948717662760215065784116654734290374983906448207065425365852408720566771005345821995341556493590254118091846659097349200248570452085641250044738949182704974520704370036542579394575574913724915713)\n\nFalse\n\n\n\nnf[7]/114689\n\n9106268965752186405773463110818163752233991481723476361152625650968740750826648212547208641935996986118024454955917854702609434541985662158212523327009262247869952450049350838706079834460006786304075107567909269645531121898331250125751682239313156601738683820643686003638396435055834553570682260579462973839574318172464558815116581626749391315641251152532705571615644886981829338611134458123396450764186936496833100701185274214915961723337127995182593580031119299575446791424418154036863609858251201843852076223383379133238000289598800458955855329052103961332983048473420515918928565951506637819342706575976725030506905683310915700945442329953941604008255667676914945655757474715779252371155778495946746587469464160684843488975918662295274965457887082037460184558511575570318625886351712499453155527762335682281851520733417380809781252979478377941937578568481859702438295520231435016188495646093490407803983345420364088331996467459309353537828143080691834120737157445502646809195267166779721413577366833939771467773331873590129210913628329073978766992198221682739812652450408607796042492802295258713711959073218748776359806123717024800451461326745599716651128725627280643537507664130920416107218492950792456907321580171946770433\n\n\n\nis_prime(9106268965752186405773463110818163752233991481723476361152625650968740750826648212547208641935996986118024454955917854702609434541985662158212523327009262247869952450049350838706079834460006786304075107567909269645531121898331250125751682239313156601738683820643686003638396435055834553570682260579462973839574318172464558815116581626749391315641251152532705571615644886981829338611134458123396450764186936496833100701185274214915961723337127995182593580031119299575446791424418154036863609858251201843852076223383379133238000289598800458955855329052103961332983048473420515918928565951506637819342706575976725030506905683310915700945442329953941604008255667676914945655757474715779252371155778495946746587469464160684843488975918662295274965457887082037460184558511575570318625886351712499453155527762335682281851520733417380809781252979478377941937578568481859702438295520231435016188495646093490407803983345420364088331996467459309353537828143080691834120737157445502646809195267166779721413577366833939771467773331873590129210913628329073978766992198221682739812652450408607796042492802295258713711959073218748776359806123717024800451461326745599716651128725627280643537507664130920416107218492950792456907321580171946770433)\n\nFalse\n\n\nLas factorizaciones son:\nF_5 = 641*6700417\nF_6 = 274177*67280421310721\nF_7 = 59649589127497217*5704689200685129054721\nF_8 = 1238926361552897 * 93461639715357977769163558199606896584051237541638188580280321\nF_9 = 2424833 * 5529373746539492451469451709955220061537996975706118061624681552800446063738635599565773930892108210210778168305399196915314944498011438291393118209 (El segundo factor no podemos factorizarlo o comprobar si realmente es primo)\nF_10 = 45592577 * 3942951359960012586542991835686376608231592127249807732373409846031135195659174148737161255930050543559319182152642816343958573976075461198274610155058226350701077796608546283231637018483208223116080561800334422176622099740983337736621316898600121619871377542107047343253864459964167331555646795960321\nF_11 = 319489 * 101152171346465785365739905563790778275446424351747584524444802254614885454171789617787158279386499891040749324458425859713854183244152133860909616251101863039512713637405344446131784663602352840930541077733717180487566766438342966931062084574042206368862921265008513729385286790910065162204496552694867070609361616173540692858549041708993328392702647150062512506151403207406283761595736673720405375033810606080158013948717662760215065784116654734290374983906448207065425365852408720566771005345821995341556493590254118091846659097349200248570452085641250044738949182704974520704370036542579394575574913724915713\nF_12 = 114689 * 9106268965752186405773463110818163752233991481723476361152625650968740750826648212547208641935996986118024454955917854702609434541985662158212523327009262247869952450049350838706079834460006786304075107567909269645531121898331250125751682239313156601738683820643686003638396435055834553570682260579462973839574318172464558815116581626749391315641251152532705571615644886981829338611134458123396450764186936496833100701185274214915961723337127995182593580031119299575446791424418154036863609858251201843852076223383379133238000289598800458955855329052103961332983048473420515918928565951506637819342706575976725030506905683310915700945442329953941604008255667676914945655757474715779252371155778495946746587469464160684843488975918662295274965457887082037460184558511575570318625886351712499453155527762335682281851520733417380809781252979478377941937578568481859702438295520231435016188495646093490407803983345420364088331996467459309353537828143080691834120737157445502646809195267166779721413577366833939771467773331873590129210913628329073978766992198221682739812652450408607796042492802295258713711959073218748776359806123717024800451461326745599716651128725627280643537507664130920416107218492950792456907321580171946770433\nDadas las longitudes de los últimos factores, necesitamos recurrir a otras herramientas extra para comprobar si son primos o se pueden seguir descomponiendo en factores.\n\n\nEjercicio 5\n\nR.&lt;x&gt; = ZZ[]\ndef criba(n,t):\n    Zn = IntegerModRing(n)\n    S = [b for b in prime_range(100) if kronecker_symbol(n,b)==1]\n    B = [-1]\n    B.extend(S)\n    lx = []\n    x1 = 0\n    for k in range(2*t+1):\n        if k % 2 == 0:\n            lx.append(x1)\n            x1 += 1\n        else:\n            lx.append(-x1)\n    m = integer_floor(sqrt(n))\n    pares = []\n    i = 0\n    k = 0\n    while i &lt; t+1:\n        b = (lx[k]+m)^2-n\n        \n\nHe intentado programarlo pero no entiendo el algoritmo descrito en los apuntes y no he encontrado ayuda en internet. El paso 3 no tengo forma de entender el cálculo de los \\(a_i\\) ni de los \\(b_i\\)."
  },
  {
    "objectID": "Criptografía/Archivos ipynb/Distribucion_de_Claves.html",
    "href": "Criptografía/Archivos ipynb/Distribucion_de_Claves.html",
    "title": "Distribución de claves",
    "section": "",
    "text": "Supongamos que \\(p=150001\\) y \\(\\alpha=7\\) en el esquema de predistribución de claves (EPC) de Diffie-Hellman. Supongamos que las claves privadas de \\(U\\), \\(V\\) y \\(W\\) son \\(a_U=101459\\), \\(a_V=123967\\) y \\(a_W=99544\\).\n\np = 150001\nalpha = 7\nZp = IntegerModRing(p)\n\n\n\n1. Calcule las claves públicas de \\(U\\), \\(V\\) y \\(W\\).\n\n# Clave pública de U:\nau = 101459\nbu = Zp(alpha^au); bu\n\n36138\n\n\n\n# Clave pública de V:\nav = 123967\nbv = Zp(alpha^av); bv\n\n106355\n\n\n\n# Clave pública de W:\naw = 99544\nbw = Zp(alpha^aw); bw\n\n93325\n\n\n\n\n2. Muestre los cálculos realizados por \\(U\\) para obtener \\(K_{U,V}\\) y \\(K_{U,W}\\).\n\nkuv = Zp(bv^au); kuv\n\n75452\n\n\n\nkuw = Zp(bw^au); kuw\n\n119360\n\n\n\n\n3. Verifique \\(V\\) calcula la misma clave \\(K_{U,V}\\) de \\(U\\).\n\nkvu = Zp(bu^av); kvu\n\n75452\n\n\n\nkuv == kvu\n\nTrue\n\n\n\nfactor(p-1)\n\n2^4 * 3 * 5^5"
  },
  {
    "objectID": "Curvas Elípticas.html",
    "href": "Curvas Elípticas.html",
    "title": "Curvas Elípticas",
    "section": "",
    "text": "1. Dar un ejemplo de una curva elíptica sobre \\(\\mathbb{R}\\) con exactamente dos puntos de orden \\(2\\) y otra con exactamente \\(4\\) puntos de orden \\(2\\).\nUna curva elíptica sobre \\(\\mathbb{R}\\) con exactamente dos puntos de orden \\(2\\) es: \\[y^2=x^3-125,\\] hay dos puntos para \\(y=0\\) que son \\((5,0)\\) y \\((-5,0)\\) que además son opuestos entre sí.\nUna curva elíptica sobre \\(\\mathbb{R}\\) con exactamente cuatro puntos de orden \\(2\\) es: \\[y^2=x^3-n^2x,\\] para cualquier \\(n\\) nos quedan los puntos \\((0,0)\\), \\((n,0)\\), \\((-n,0)\\) y el infinito.\n\n\n2. Sea \\(P\\neq \\mathcal{O}\\) un punto de una curva elíptica sobre \\(\\mathbb{R}\\). Dar una condición geométrica que caracterice los puntos con orden \\(2\\), \\(3\\) y \\(4\\).\nSi tenemos dos soluciones \\(P=(x_1,y_1)\\in \\mathbb{R}^2\\) y \\(Q=(x_2,y_2)\\in\\mathbb{R}^2\\) de nuestra ecuación \\[y^2 = x^3 + Ax^2 + Bx + C,\\] entonces calculamos \\(P + Q\\) de la manera siguiente:\n\nSi \\(P\\neq Q\\) son puntos distintos, entonces trazamos la recta que pasa por P y Q. Dado que nuestra curva está dada por una ecuación de grado 3, esta recta interseca la curva elíptica en un tercer punto. Luego, definimos la suma \\(P + Q\\) como el punto obtenido al considerar la simetría ortogonal de este último punto respecto al eje \\(X\\).\nSi \\(P = Q\\) son el mismo punto, entonces consideramos la recta tangente a la curva elíptica pasando por el punto \\(P\\). Tal como antes, la recta tangente interseca la curva elíptica en un tercer punto. Luego, definimos la suma \\(P+P:= 2P\\) como el punto obtenido al considerar la simetría ortogonal de este último punto respecto al eje \\(X\\).} \\end{itemize} Y así sucesivamente podemos obtener puntos de orden \\(3\\) y \\(4\\).\n\n\n\n3. Cada uno de los puntos siguientes tiene orden finito en la curva elíptica dada. Encontrar su orden.\n\n\\(y^2=x^3+256\\), \\(P=(0,16)\\).\n\n\n\nCódigo\nF1 = EllipticCurve([0,256]);F1\n\n\nElliptic Curve defined by y^2 = x^3 + 256 over Rational Field\n\n\n\n\nCódigo\nP = F1(0,16); P.additive_order()\n\n\n3\n\n\n\n\\(y^2=x^3+\\frac{1}{4}x\\), \\(P=(1/2,1/2)\\).\n\n\n\nCódigo\nF2 = EllipticCurve([0,0,0,1/4,0]);F2\n\n\nElliptic Curve defined by y^2 = x^3 + 1/4*x over Rational Field\n\n\n\n\nCódigo\nP2 = F2(1/2,1/2); P2.additive_order()\n\n\n4\n\n\n\n\\(y^2=x^3-43x+166\\), \\(P=(3,8)\\).\n\n\n\nCódigo\nF3 = EllipticCurve([0,0,0,-43,166]); F3\n\n\nElliptic Curve defined by y^2 = x^3 - 43*x + 166 over Rational Field\n\n\n\n\nCódigo\nP3 = F3(3,8); P3.additive_order()\n\n\n7\n\n\n\n\n4. Para todas las potencias primas de \\(q=p^r\\) hasta \\(27\\) encontrar el orden y el tipo del grupo \\(E(\\mathbb{F}_q)\\) de la curva elíptica \\(E\\,:\\,y^2=x^3-x\\) y \\(E\\,:\\,y^2=x^3-1\\) \\((p\\neq 3)\\).\n\n\nCódigo\npotp = [5,5**2,7,11,13,17,19,23]\n\n\n\n\nCódigo\nfor q in potp:\n    F = GF(q)\n    E1 = EllipticCurve(F,[F(0),F(0),F(0),F(-1),F(0)])\n    E2 = EllipticCurve(F,[F(0),F(0),F(0),F(0),F(-1)])\n    print(\"q= \"+str(q)+'\\n')\n    print(E1)\n    print(E1.abelian_group())\n    print('\\n')\n    print(E2)\n    print(E2.abelian_group())\n    print('\\n')\n    \n\n\nq= 5\n\nElliptic Curve defined by y^2 = x^3 + 4*x over Finite Field of size 5\nAdditive abelian group isomorphic to Z/4 + Z/2 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 4*x over Finite Field of size 5\n\n\nElliptic Curve defined by y^2 = x^3 + 4 over Finite Field of size 5\nAdditive abelian group isomorphic to Z/6 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 4 over Finite Field of size 5\n\n\nq= 25\n\nElliptic Curve defined by y^2 = x^3 + 4*x over Finite Field in z2 of size 5^2\nAdditive abelian group isomorphic to Z/8 + Z/4 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 4*x over Finite Field in z2 of size 5^2\n\n\nElliptic Curve defined by y^2 = x^3 + 4 over Finite Field in z2 of size 5^2\nAdditive abelian group isomorphic to Z/6 + Z/6 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 4 over Finite Field in z2 of size 5^2\n\n\nq= 7\n\nElliptic Curve defined by y^2 = x^3 + 6*x over Finite Field of size 7\nAdditive abelian group isomorphic to Z/4 + Z/2 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 6*x over Finite Field of size 7\n\n\nElliptic Curve defined by y^2 = x^3 + 6 over Finite Field of size 7\nAdditive abelian group isomorphic to Z/2 + Z/2 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 6 over Finite Field of size 7\n\n\nq= 11\n\nElliptic Curve defined by y^2 = x^3 + 10*x over Finite Field of size 11\nAdditive abelian group isomorphic to Z/6 + Z/2 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 10*x over Finite Field of size 11\n\n\nElliptic Curve defined by y^2 = x^3 + 10 over Finite Field of size 11\nAdditive abelian group isomorphic to Z/12 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 10 over Finite Field of size 11\n\n\nq= 13\n\nElliptic Curve defined by y^2 = x^3 + 12*x over Finite Field of size 13\nAdditive abelian group isomorphic to Z/4 + Z/2 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 12*x over Finite Field of size 13\n\n\nElliptic Curve defined by y^2 = x^3 + 12 over Finite Field of size 13\nAdditive abelian group isomorphic to Z/6 + Z/2 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 12 over Finite Field of size 13\n\n\nq= 17\n\nElliptic Curve defined by y^2 = x^3 + 16*x over Finite Field of size 17\nAdditive abelian group isomorphic to Z/4 + Z/4 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 16*x over Finite Field of size 17\n\n\nElliptic Curve defined by y^2 = x^3 + 16 over Finite Field of size 17\nAdditive abelian group isomorphic to Z/18 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 16 over Finite Field of size 17\n\n\nq= 19\n\nElliptic Curve defined by y^2 = x^3 + 18*x over Finite Field of size 19\nAdditive abelian group isomorphic to Z/10 + Z/2 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 18*x over Finite Field of size 19\n\n\nElliptic Curve defined by y^2 = x^3 + 18 over Finite Field of size 19\nAdditive abelian group isomorphic to Z/14 + Z/2 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 18 over Finite Field of size 19\n\n\nq= 23\n\nElliptic Curve defined by y^2 = x^3 + 22*x over Finite Field of size 23\nAdditive abelian group isomorphic to Z/12 + Z/2 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 22*x over Finite Field of size 23\n\n\nElliptic Curve defined by y^2 = x^3 + 22 over Finite Field of size 23\nAdditive abelian group isomorphic to Z/24 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + 22 over Finite Field of size 23\n\n\n\n\n\n\n5. Sea \\(E\\) la curva elíptica \\(y^2+y=x^3-x\\) definida sobre \\(\\mathbb{F}_{751}\\). Esta curva contiene \\(N=727\\) puntos. Construir un criptosistema de Menezes-Vanstone y usarlo para transmitir el mensaje STOPNOW.\n\n\nCódigo\nalfabeto = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']\nmensaje = 'STOPNOW'\nm = 22*26^0+14*26^1+13*26^2+15*26^3+14*26^4+19*26^5+18*26^6\n\nF = GF(751)\nE = EllipticCurve(F,[0,0,1,-1,0])\nptos = E.points()\np = randint(0,len(ptos))\nP = ptos[p] # Punto de la curva E aleatorio\n\ndef C():\n    mp = m.digits(751)\n    k = randint(0,P.order()-1) # Clave privada aleatoria\n    gamma = k*P # Clave Pública de Bob\n    d = randint(0,P.order()-1)\n    beta = d*P #Clave Pública de Alice\n    x1 = (mp[0],mp[1])\n    x2 = (mp[2],mp[3])\n    c1,c2,c3 = d*gamma\n    y1 = (x1[0]*c1)%751,(x1[1]*c2)%751\n    y2 = (x2[0]*c1)%751,(x2[1]*c2)%751\n    return gamma,y1,y2\n\n\n\n\n\nCódigo\nC()\n\n\n((566 : 719 : 1), (434, 65), (434, 494))\n\n\n\n\n6. Implemente el método de curvas elípticas de Lenstra y factorice los siguientes números:\n\n\\(N = 199843247\\)\n\\(N = 8746327411126827157\\)\n\\(N = 10817310890509097139\\)\n\\(N = 104681783926243375222281565321123456789\\)\n\n\n\nCódigo\ndef lenstra_ecm(N, B):\n    \"\"\"\n    Implementación del método de curvas elípticas de Lenstra en SageMath.\n    N: Número a factorizar.\n    B: Límite de primos pequeños para el escalado del punto.\n    \"\"\"\n    \n    while True:\n        # Seleccionar un punto y una curva aleatoria\n        a = randint(1, N-1)\n        x0 = randint(1, N-1)\n        y0 = randint(1, N-1)\n        b = (y0^2 - x0^3 - a*x0) % N\n        \n        try:\n            E = EllipticCurve(GF(N), [a, b])  # Crear la curva elíptica sobre Z/NZ\n            P = E(x0, y0)  # Punto sobre la curva\n        except:\n            d = gcd(4*a^3 + 27*b^2, N)\n            if 1 &lt; d &lt; N:\n                return d  # Factor encontrado\n            continue\n        \n        # Aplicar el escalado por primos pequeños\n        for p in primes(B):\n            e = int(log(B) / log(p))  # Exponente máximo de p tal que p^e &lt;= B\n            P = p^e * P  # Multiplicación en la curva\n            \n            # Verificar si encontramos un factor\n            if P[2] == 0:  # Si la coordenada Z es 0, significa que hubo un problema con N\n                d = gcd(P[0], N)\n                if 1 &lt; d &lt; N:\n                    return d  # Factor encontrado\n        \n        # Si fallamos, repetimos con otra curva\n\n\n\n\nCódigo\nN = 199843247\nB = 10.e4\nfactor = lenstra_ecm(N,B)\nprint(f\"Factor encontrado: {factor}\")\n\n\nFactor encontrado: 19423\n\n\n\n\nCódigo\nN = 8746327411126827157\nB = 10.e4\nfactor = lenstra_ecm(N,B)\nprint(f\"Factor encontrado: {factor}\")\n\n\nFactor encontrado: 29\n\n\n\n\nCódigo\nN = 10817310890509097139\nB = 10.e4\nfactor = lenstra_ecm(N,B)\nprint(f\"Factor encontrado: {factor}\")\n\n\nFactor encontrado: 9\n\n\nNota: El valor de \\(B\\) se utiliza para acotar los primos a tomar, en el caso en el que observemos que el programa se queda calculando demasiado tiempo, pillemos con pinzas el demasiado, es recomendable probar a aumentar el valor de \\(B\\) progresivamente, ya que es probable que el factor primo esté por encima de ese primer cribado.",
    "crumbs": [
      "Notebooks",
      "Curvas Elípticas"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Inicio",
    "section": "",
    "text": "Esta página contiene una recopilación de teoría y ejercicios básicos sobre códigos algebraicos y criptografía.",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "Criptografía/Archivos ipynb/Firmas_Digitales.html",
    "href": "Criptografía/Archivos ipynb/Firmas_Digitales.html",
    "title": "Firmas Digitales",
    "section": "",
    "text": "1.\n\np = 31847\nalpha = 5\nbeta = 25703\nZp1 = IntegerModRing(p-1)\nZu = [a for a in Zp1.list() if a.is_unit()]\n\nk = sample(Zu,1)[0]\n\n\n\nk\n\n26839\n\n\n\n# Baby step giant step\ndef bsgs(a,b,n):\n    Zn = IntegerModRing(n)\n    m = ceil(sqrt(n))\n    t = []\n    for j in range(m):\n        t.append((j,Zn(a)^j))\n    am = Zn(a)^(-m)\n    c = b\n    i = 0\n    while i &lt; m:\n        for j in range(m):\n            if t[j][1] == c:\n                return i*m+j\n        c = Zn(c*am)\n        i += 1\n\n\np = 31847\nalpha = 5\nbeta = 25703\nZp1 = IntegerModRing(p-1)\nr1 = 23972\ns1 = 31396\nx1 = 8990\na = bsgs(alpha,beta,p)\nk1 = bsgs(alpha,r1,p)\nr2 = 23972\ns2 = 20481\nx2 = 31415\nk2 = bsgs(alpha,r2,p)\n\n\nZp1(x1-a*r1)*Zp1(k1)^(-1)\n\n31396\n\n\n\nZp1(x2-a*r2)*Zp1(k2)^(-1)\n\n20481\n\n\nPor tanto, k = 1165 y a = 7459.\n\n\n2.\n\na)\n\ndef verEGS(alfa,beta,p,x,d,g):\n    Zp = IntegerModRing(p)\n    return Zp(beta^g*g^d) - Zp(alfa^x) == 0\n\n\nalfa = 5\nbeta = 26379\np = 31847\ng = 20679\nd = 11082\nx = 20543\nverEGS(alfa,beta,p,x,d,g)\n\nTrue\n\n\n\n\nb)\n\nk = bsgs(alfa,g,p); k\n\n19387\n\n\n\n\nc)\n\nZp1 = IntegerModRing(p-1)\na = bsgs(alfa,beta,p)\nl1 = Zp1(x-a*g)\nZu = [a for a in Zp1.list() if a.is_unit()] # Lista con las unidades de Z_p-1\ni = 0\nwhile True:\n    if i &gt; p-1: # Técnicamente no hace falta porque sabemos que el bucle es finito, otra cosa es el tiempo que nos lleve encontrar el k.\n        break\n    if Zp1(Zu[i]*d) == l1:\n        print('k = '+str(Zu[i]))\n        break\n    else:\n        i += 1\n\nk = 19387"
  },
  {
    "objectID": "Criptografía/Archivos ipynb/Primalidad.html",
    "href": "Criptografía/Archivos ipynb/Primalidad.html",
    "title": "Test de Primalidad",
    "section": "",
    "text": "1.\n\n\na) Probar que \\(561\\) es un número de Carmichael, sin usar el teorema de caracterización. Hacer lo mismo con \\(1729\\), \\(10585\\), \\(75361\\) y \\(1024651\\).\n\ndef carmichael(n):\n    L = [a for a in range(0,n) if gcd(n,a)==1]\n    Zn = IntegerModRing(n)\n    t = True\n    i = 0\n    while t and i &lt; len(L):\n        if Zn(L[i])^(n-1)-1 != 0:\n            t = False\n        else:\n            i += 1\n    return t\n\n\ncarmichael(561)\n\nTrue\n\n\n\ncarmichael(1729)\n\nTrue\n\n\n\n%time carmichael(10585)\n\nCPU times: user 32.3 ms, sys: 1.42 ms, total: 33.7 ms\nWall time: 33.1 ms\n\n\nTrue\n\n\n\n%time carmichael(75361)\n\nCPU times: user 134 ms, sys: 2.74 ms, total: 137 ms\nWall time: 138 ms\n\n\nTrue\n\n\n\n%time carmichael(1024651)\n\nCPU times: user 1.72 s, sys: 8.63 ms, total: 1.73 s\nWall time: 1.74 s\n\n\nTrue\n\n\n\n\nb) Probar que un número de Carmichael es par.\n\n\nc) Probar que un número de Carmichael debe ser producto de primos distintos.\n\n\nd) Dar una demostración de la caracterización que hemos enunciado en clase de los primos de Carmichael (también conocido como criterio de Korselt obtenido en 1899).\n\n\n2. Utilizar los tests de Fermat y Miller-Rabin (con \\(10\\) repeticiones) para encontrar un testigo de pseudoprimalidad o para concluir que el número es probablemente primo.\n\ndef testFermat(n,t):\n    Zn = IntegerModRing(n)\n    if n &lt; 3 or is_even(n):\n        raise Exception(\"Valor de n = \"+str(n)+\" no válido.\")\n    for i in range(0,t):\n        a = randint(2,n-2)\n        if gcd(a,n) != 1:\n            return \"Compuesto\"\n        r = Zn(a)^(n-1)\n        if r != 1:\n            return \"Compuesto\"\n    return \"Primo\"\n\ndef testMillerRabin(n,t):\n    Zn = IntegerModRing(n)\n    if n &lt; 3 or is_even(n):\n        raise Exception(\"Valor de n = \"+str(n)+\" no válido.\")\n    k = factor(n-1)[0][1]\n    m = (n-1)/(2**k)\n    for j in range(0,t):\n        a = randint(2,n-1)\n        if gcd(a,n) != 1:\n            return \"Compuesto\"\n        b = Zn(a)^m\n        if Zn(b) == 1:\n            return \"Primo\"\n        for i in range(0,k):\n            if Zn(b) == -1:\n                return \"Primo\"\n            else:\n                b = Zn(b)^2\n    return \"Compuesto\"\n\n\nna = 294409\nnb = 118901509\nnc = 118901521\nnd = 118901527\nne = 118915387\nt = 10\n\n\nfor k in [na,nb,nc,nd,ne]:\n    print(\"El test de Fermat para n = \"+str(k)+\" es: \"+str(testFermat(k,t)))\n    print(\"\\n\")\n    print(\"El test de Miller-Rabin para n = \"+str(k)+\" es: \"+str(testMillerRabin(k,t)))\n    print(\"\\n\")\n\nEl test de Fermat para n = 294409 es: Compuesto\n\n\nEl test de Miller-Rabin para n = 294409 es: Compuesto\n\n\nEl test de Fermat para n = 118901509 es: Primo\n\n\nEl test de Miller-Rabin para n = 118901509 es: Primo\n\n\nEl test de Fermat para n = 118901521 es: Primo\n\n\nEl test de Miller-Rabin para n = 118901521 es: Compuesto\n\n\nEl test de Fermat para n = 118901527 es: Primo\n\n\nEl test de Miller-Rabin para n = 118901527 es: Primo\n\n\nEl test de Fermat para n = 118915387 es: Compuesto\n\n\nEl test de Miller-Rabin para n = 118915387 es: Compuesto\n\n\n\n\n\n\n3. Repetir el ejercicio anterior usando el criterio de Solovay-Strassen.\n\ndef testSolovayStrassen(n,t):\n    Zn = IntegerModRing(n)\n    if n &lt; 3 or is_even(n):\n        raise Exception(\"Valor de n = \"+str(n)+\" no válido.\")\n    for i in range(0,t):\n        a = randint(2,n-2)\n        r = Zn(a)^((n-1)/2)\n        if r != 1 and r != n-1:\n            return \"Compuesto\"\n        s = jacobi_symbol(a,n)\n        if r != Zn(s):\n            return \"Compuesto\"\n    return \"Primo\"\n\n\nfor k in [na,nb,nc,nd,ne]:\n    print(\"El test de Solovay-Strassen para n = \"+str(k)+\" es: \"+str(testSolovayStrassen(k,t)))\n    print(\"\\n\")\n\nEl test de Solovay-Strassen para n = 294409 es: Compuesto\n\n\nEl test de Solovay-Strassen para n = 118901509 es: Primo\n\n\nEl test de Solovay-Strassen para n = 118901521 es: Compuesto\n\n\nEl test de Solovay-Strassen para n = 118901527 es: Primo\n\n\nEl test de Solovay-Strassen para n = 118915387 es: Compuesto\n\n\n\n\n\n\n4. Comprobar los primos de Mersenne hasta las posibilidades de vuestro ordenador.\n\n# Potencias primas para generar los números de Mersenne:\nN = [2,3,5,7,13,17,19,31,61,89,107,127,521]\nt = 10\nk = 1\n\nwhile k &lt; len(N):\n    Mn = 2^N[k]-1\n    print(\"El test de Fermat para el \"+str(k+1)+\"-ésimo número de Mersenne es: \"+str(testFermat(Mn,t)))\n    print(\"\\n\")\n    print(\"El test de Miller-Rabin para el \"+str(k+1)+\"-ésimo número de Mersenne es: \"+str(testMillerRabin(Mn,t)))\n    print(\"\\n\")\n    print(\"El test de Solovay-Strassen para el \"+str(k+1)+\"-ésimo número de Mersenne es: \"+str(testSolovayStrassen(Mn,t)))\n    print(\"\\n\")\n    k += 1\n\nEl test de Fermat para el 2-ésimo número de Mersenne es: Primo\n\n\nEl test de Miller-Rabin para el 2-ésimo número de Mersenne es: Primo\n\n\nEl test de Solovay-Strassen para el 2-ésimo número de Mersenne es: Primo\n\n\nEl test de Fermat para el 3-ésimo número de Mersenne es: Primo\n\n\nEl test de Miller-Rabin para el 3-ésimo número de Mersenne es: Primo\n\n\nEl test de Solovay-Strassen para el 3-ésimo número de Mersenne es: Primo\n\n\nEl test de Fermat para el 4-ésimo número de Mersenne es: Primo\n\n\nEl test de Miller-Rabin para el 4-ésimo número de Mersenne es: Primo\n\n\nEl test de Solovay-Strassen para el 4-ésimo número de Mersenne es: Primo\n\n\nEl test de Fermat para el 5-ésimo número de Mersenne es: Primo\n\n\nEl test de Miller-Rabin para el 5-ésimo número de Mersenne es: Primo\n\n\nEl test de Solovay-Strassen para el 5-ésimo número de Mersenne es: Primo\n\n\nEl test de Fermat para el 6-ésimo número de Mersenne es: Primo\n\n\nEl test de Miller-Rabin para el 6-ésimo número de Mersenne es: Primo\n\n\nEl test de Solovay-Strassen para el 6-ésimo número de Mersenne es: Primo\n\n\nEl test de Fermat para el 7-ésimo número de Mersenne es: Primo\n\n\nEl test de Miller-Rabin para el 7-ésimo número de Mersenne es: Primo\n\n\nEl test de Solovay-Strassen para el 7-ésimo número de Mersenne es: Primo\n\n\nEl test de Fermat para el 8-ésimo número de Mersenne es: Primo\n\n\nEl test de Miller-Rabin para el 8-ésimo número de Mersenne es: Primo\n\n\nEl test de Solovay-Strassen para el 8-ésimo número de Mersenne es: Primo\n\n\nEl test de Fermat para el 9-ésimo número de Mersenne es: Primo\n\n\nEl test de Miller-Rabin para el 9-ésimo número de Mersenne es: Primo\n\n\nEl test de Solovay-Strassen para el 9-ésimo número de Mersenne es: Primo\n\n\nEl test de Fermat para el 10-ésimo número de Mersenne es: Primo\n\n\nEl test de Miller-Rabin para el 10-ésimo número de Mersenne es: Primo\n\n\nEl test de Solovay-Strassen para el 10-ésimo número de Mersenne es: Primo\n\n\nEl test de Fermat para el 11-ésimo número de Mersenne es: Primo\n\n\nEl test de Miller-Rabin para el 11-ésimo número de Mersenne es: Primo\n\n\nEl test de Solovay-Strassen para el 11-ésimo número de Mersenne es: Primo\n\n\nEl test de Fermat para el 12-ésimo número de Mersenne es: Primo\n\n\nEl test de Miller-Rabin para el 12-ésimo número de Mersenne es: Primo\n\n\nEl test de Solovay-Strassen para el 12-ésimo número de Mersenne es: Primo\n\n\nEl test de Fermat para el 13-ésimo número de Mersenne es: Primo\n\n\nEl test de Miller-Rabin para el 13-ésimo número de Mersenne es: Primo\n\n\nEl test de Solovay-Strassen para el 13-ésimo número de Mersenne es: Primo\n\n\n\n\n\ntestSolovayStrassen(2^44497-1,10) #N=27\n\n'Primo'\n\n\n\n\nHacer lo mismo con los primos de Fermat.\n\n# Números de Fermat\nk = 1\nN = 17\nt = 15\nwhile k &lt; N:\n    Fn = 2^(2^k)+1\n    print(\"El test de Fermat para el \"+str(k)+\"-ésimo número de Fermat es: \"+str(testFermat(Fn,t)))\n    print(\"\\n\")\n    #print(\"El test de Miller-Rabin para el \"+str(k+1)+\"-ésimo número de Fermat es: \"+str(testMillerRabin(Fn,t)))\n    #print(\"\\n\")\n    print(\"El test de Solovay-Strassen para el \"+str(k)+\"-ésimo número de Fermat es: \"+str(testSolovayStrassen(Fn,t)))\n    print(\"\\n\")\n    k += 1\n\nEl test de Fermat para el 1-ésimo número de Fermat es: Primo\n\n\nEl test de Solovay-Strassen para el 1-ésimo número de Fermat es: Primo\n\n\nEl test de Fermat para el 2-ésimo número de Fermat es: Primo\n\n\nEl test de Solovay-Strassen para el 2-ésimo número de Fermat es: Primo\n\n\nEl test de Fermat para el 3-ésimo número de Fermat es: Primo\n\n\nEl test de Solovay-Strassen para el 3-ésimo número de Fermat es: Primo\n\n\nEl test de Fermat para el 4-ésimo número de Fermat es: Primo\n\n\nEl test de Solovay-Strassen para el 4-ésimo número de Fermat es: Primo\n\n\nEl test de Fermat para el 5-ésimo número de Fermat es: Compuesto\n\n\nEl test de Solovay-Strassen para el 5-ésimo número de Fermat es: Compuesto\n\n\nEl test de Fermat para el 6-ésimo número de Fermat es: Compuesto\n\n\nEl test de Solovay-Strassen para el 6-ésimo número de Fermat es: Compuesto\n\n\nEl test de Fermat para el 7-ésimo número de Fermat es: Compuesto\n\n\nEl test de Solovay-Strassen para el 7-ésimo número de Fermat es: Compuesto\n\n\nEl test de Fermat para el 8-ésimo número de Fermat es: Compuesto\n\n\nEl test de Solovay-Strassen para el 8-ésimo número de Fermat es: Compuesto\n\n\nEl test de Fermat para el 9-ésimo número de Fermat es: Compuesto\n\n\nEl test de Solovay-Strassen para el 9-ésimo número de Fermat es: Compuesto\n\n\nEl test de Fermat para el 10-ésimo número de Fermat es: Compuesto\n\n\nEl test de Solovay-Strassen para el 10-ésimo número de Fermat es: Compuesto\n\n\nEl test de Fermat para el 11-ésimo número de Fermat es: Compuesto\n\n\nEl test de Solovay-Strassen para el 11-ésimo número de Fermat es: Compuesto\n\n\nEl test de Fermat para el 12-ésimo número de Fermat es: Compuesto\n\n\nEl test de Solovay-Strassen para el 12-ésimo número de Fermat es: Compuesto\n\n\nEl test de Fermat para el 13-ésimo número de Fermat es: Compuesto\n\n\nEl test de Solovay-Strassen para el 13-ésimo número de Fermat es: Compuesto\n\n\nEl test de Fermat para el 14-ésimo número de Fermat es: Compuesto\n\n\nEl test de Solovay-Strassen para el 14-ésimo número de Fermat es: Compuesto\n\n\nEl test de Fermat para el 15-ésimo número de Fermat es: Compuesto\n\n\nEl test de Solovay-Strassen para el 15-ésimo número de Fermat es: Compuesto\n\n\nEl test de Fermat para el 16-ésimo número de Fermat es: Compuesto\n\n\nEl test de Solovay-Strassen para el 16-ésimo número de Fermat es: Compuesto"
  },
  {
    "objectID": "Criptografía/Archivos ipynb/LogaritmoDiscreto.html",
    "href": "Criptografía/Archivos ipynb/LogaritmoDiscreto.html",
    "title": "4. Logaritmo discreto. ElGamal.",
    "section": "",
    "text": "1. Calcule, usando el algoritmo paso de gigante paso de bebé:\n\n# Baby step giant step\ndef bsgs(a,b,n):\n    m = ceil(sqrt(n))\n    t = []\n    for j in range(m):\n        t.append((j,a^j % n))\n    am = a^(-m) % n\n    c = b\n    i = 0\n    while i &lt; m:\n        for j in range(m):\n            if t[j][1] == c:\n                return i*m+j\n        c = (c*am)%n\n        i += 1\n        \n\n\n\na) \\(\\log_{11}(21)\\) en \\(\\mathbb{F}_{71}\\).\n\nbsgs(11,21,71)\n\n37\n\n\n\n\nb) \\(\\log_{156}(116)\\) en \\(\\mathbb{F}_{593}\\).\n\nbsgs(156,116,593)\n\n59\n\n\n\n(156^59)%593\n\n116\n\n\n\n\nc) \\(\\log_{650}(2213)\\) en \\(\\mathbb{F}_{3571}\\).\n\nbsgs(650,2213,3571)\n\n319\n\n\n\n(650^319)%3571\n\n2213\n\n\n\n\n2. Calcule, usando el algoritmo de Pohlig-Hellman, el \\(\\log_g(a)\\) en \\(\\mathbb{F}_p\\) en los casos siguientes:\n\n# Pohlig-Hellman\n\ndef ph(g,a,n):\n    Zn = IntegerModRing(n)\n    ff = []\n    nf = len(n.factor())\n    for k in range(nf):\n        ff.append((n.factor()[k][0])**(n.factor()[k][1]))\n    gi = []\n    hi = []\n    xi = []\n    for i in range(0,nf):\n        gi.append(Zn(g)**(n/ff[i]))\n        hi.append(Zn(a)**(n/ff[i]))\n        xi.append(bsgs(gi[i],hi[i],n))\n    return crt(xi,ff)\n\n\n\na) \\(p=433\\), \\(g=7\\), \\(a=166\\).\n\nph(7,166,433)\n\n47\n\n\n\n\nb) \\(p=746497\\), \\(g=10\\), \\(a=243278\\).\n\nph(10,243278,746497)\n\n223755\n\n\n\n\nc) \\(p=41022299\\), \\(g=2\\), \\(a=39183497\\).\n\nph(2,39183497,41022299)\n\n33703314\n\n\n\n\nd) \\(p=1291799\\), \\(g=17\\), \\(a=192988\\).\n\nph(17,192988,1291799)\n\n984414\n\n\n\n\n3. Dado el texto cifrado: (en el documento) que se ha cifrado usando el criptosistema de ElGamal con \\(p=31847\\), y que \\(\\log_5(18074)=7899\\). Cada elemento de \\(\\mathbb{Z}_p\\) representa tres letras en inglés.\n\np = 31847\nZp = IntegerModRing(p)\nalpha = 5\na = 7899\nbeta = 18074\n\n\nd1 = Zp(14409)*Zp(3781^a)^(-1)\nd1\n\n12354\n\n\n\n(12354).digits(26)\n\n[4, 7, 18]\n\n\n\n(31552, 3930)\nx = Zp(3930)*Zp(31552^a)^(-1)\n\n\nx\n\n12662\n\n\n\n(12662.digits(26))\n\n[0, 19, 18]\n\n\n\nZp(15442)*Zp(27214^a)^(-1)\n\n8884\n\n\n\n010.str(26)\n\n'a'\n\n\n\nZZ(Zp(15442)*Zp(27214^a)^(-1)).digits(26)\n\n[18, 3, 13]\n\n\n\nL = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']\n\n\n\nfor i in [18,19,0]:\n    print (L[i])\n\nS\nT\nA\n\n\n\n\n4. Sea \\(p=227\\).\n\n\na) Compruebe que \\(a=2\\) es un elemento primitivo:\n\nreset()\np = 227\nZp.&lt;a&gt; = GF(p)\n\n\norder(Zp(2))\n\n227\n\n\n\n\nb) Calcule \\(a^{32}\\), \\(a^{40}\\), \\(a^{59}\\) y \\(a^{156}\\) módulo \\(p\\), y factorícelos usando la base de divisores \\(\\mathcal{B}=\\{2,3,5,7,11\\}\\).\n\n(Zp(2)^32)\n\n176\n\n\n\n176.factor()\n\n2^4 * 11\n\n\n\nZp(2)^40\n\n110\n\n\n\n110.factor()\n\n2 * 5 * 11\n\n\n\nZp(2)^59\n\n60\n\n\n\n60.factor()\n\n2^2 * 3 * 5\n\n\n\nZp(2)^156\n\n28\n\n\n\n28.factor()\n\n2^2 * 7\n\n\n\n\nc) Calcule \\(\\log\\,3\\), \\(\\log\\,5\\), \\(\\log\\,7\\), y \\(\\log\\,11\\) en base \\(a\\).\nPara ello tenemos que resolver el siguiente sistema de ecuaciones: \\[176=4\\log 2+\\log 11,\\] \\[110 = \\log 2 + \\log 5 +\\log 11,\\] \\[60=2 \\log 2 + \\log 3 + \\log 5,\\] \\[28 = 2 \\log 2 + \\log 7.\\] Recordemos que \\(a=2\\), con lo que \\(\\log 2 = 1\\) en nuestra base.\nEl sistema queda casi inmediato, con la siguiente forma: \\[172 = \\log 11,\\] \\[109 = \\log 5 +\\log 11,\\] \\[58 = \\log 3 + \\log 5,\\] \\[26 = \\log 7.\\]\nCon lo que operando por reducción, podemos sacar \\(\\log 5\\) y \\(\\log 3\\). La solución es: \\(\\log 3 = 121\\), \\(\\log 5 = -63 \\equiv 164\\), \\(\\log 7 = 26\\) y \\(\\log 11 = 172\\).\n\n\nd) Calcule \\(\\log 173\\) en base \\(a\\).\nHaciendo uso del consejo, tenemos que factorizar \\(173\\cdot 2^{177}\\):\n\nZp(173)*Zp(2^(177))\n\n168\n\n\n\n168.factor()\n\n2^3 * 3 * 7\n\n\nTenemos pues que \\(\\log 173=3 \\log 2 + \\log 3 + \\log 7 \\text{ mód }227\\).\n\nZp(3+121+26)\n\n150\n\n\nLa solución es \\(\\log 173 = 150\\)."
  }
]